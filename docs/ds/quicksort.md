---
title: QuickSort Lab
nav_order: 14
parent: DS Labs
layout: page

---
# QuickSort Lab
{: .no_toc}

# ðŸ•µï¸ Challenge: The AI Code Audit
Subject: Sorting Algorithms & Data Structures

Task: Identify, Debug, and Optimize the "QuickSort" Algorithm


## Task Summary
{: .no_toc .text-delta }
1. TOC
{:toc}




##  ðŸš© Part 1: The Investigation
The code below was generated by an AI. It compiles and runs for some inputs, but it is fundamentally broken. It contains 3 logical errors that lead to infinite loops, crashes, or incorrect sorting.

Your Goal: Trace the code on paper with the array [5, 2, 8]. Can you find the 3 bugs?

```java
public class BuggyQuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low == high) return;

        int pivotIndex = partition(arr, low, high);

        quickSort(arr, low, pivotIndex);
        quickSort(arr, pivotIndex, high);
    }

    private static int partition(int[] arr, int lo, int hi) {
        int i = lo, j = hi + 1;
        while (true) {
            while (less(a[++i], a[lo]))
                if (i == hi) break;
            while (less(a[lo], a[--j]))
                if (j == lo) break;

            if (i >= j) break;
            swap(a, i, j);
        }
        return j;
    }
    private static boolean less(int a, int b){
        /*implementation not shown*/
    }
    private static void swap(int[] a, int i, int j){
        /*implementation not shown*/
    }
}
```

##  ðŸ§ª Part 2: The Stress Test
Once you think you have "fixed" the code, run it against the Stress Test Script. Your code must pass all four levels:

- Level 1: Small Random Array (Basic logic)

- Level 2: Already Sorted Array (Recursion limits)

- Level 3: All Duplicates [5, 5, 5, 5] (Partitioning efficiency)

- Level 4: 1,000+ Random Elements (Time complexity)

```java
import java.util.Arrays;
import java.util.Random;

public class QuickSortStressTest {
    public static void main(String[] args) {
        testSmallArray();
        testAlreadySorted();
        testDuplicates();
        testLargeRandomArray();
    }

    public static void testSmallArray() {
        int[] data = {3, 1, 2};
        runTest("Small Array", data);
    }

    public static void testAlreadySorted() {
        int[] data = {1, 2, 3, 4, 5};
        runTest("Already Sorted", data);
    }

    public static void testDuplicates() {
        // Many students' QuickSort logic fails or hangs on identical values
        int[] data = {5, 5, 5, 5, 5};
        runTest("All Duplicates", data);
    }

    public static void testLargeRandomArray() {
        Random rand = new Random();
        int[] data = new int[1000];
        for (int i = 0; i < 1000; i++) data[i] = rand.nextInt(10000);
        runTest("1,000 Random Elements", data);
    }

    private static void runTest(String name, int[] data) {
        int[] expected = data.clone();
        Arrays.sort(expected);
        
        try {
            // This calls the students' class
            BuggyQuickSort.quickSort(data, 0, data.length - 1);
            
            if (Arrays.equals(data, expected)) {
                System.out.println("âœ… PASS: " + name);
            } else {
                System.out.println("âŒ FAIL: " + name + " (Wrong Order)");
                System.out.println("Expected: " + Arrays.toString(expected));
                System.out.println("Actual:   " + Arrays.toString(data));
            }
        } catch (StackOverflowError e) {
            System.out.println("âŒ FAIL: " + name + " (Stack Overflow - Check your recursion/base case!)");
        } catch (Exception e) {
            System.out.println("âŒ FAIL: " + name + " (Exception: " + e.getMessage() + ")");
        }
    }
}
```

## ðŸš€ Part 3: The "Level Up" (AI Integration)

Standard QuickSort often struggles with Level 3 (Duplicates). 
If your code fails Level 3 or runs extremely slowly, use an AI tool as a "Research Consultant" with the following prompts:
- "Why does standard QuickSort have $$O(n^{2})$$ complexity when the array has many duplicate values?"
- "Explain the 'Dutch National Flag' algorithm and how it can be used to optimize QuickSort partitioning."

Task: Implement a 3-Way Partitioning version of QuickSort.


## ðŸ“ Part 4: Reflection (To be turned in)
1. The Diagnosis: List the 3 original bugs and explain why they caused the program to fail.
2. The Comparison: When would you choose Merge Sort ($$O(n \log n)$$ always) over Quick Sort ($$O(n^{2})$$ worst-case)?
3. Stability: Does your final Quick Sort maintain the relative order of equal elements? Why or why not?
4. The AI Lesson: How did the AI-generated code fail you today? How did the AI help you later?

