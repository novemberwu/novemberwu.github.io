---
title: QuickSort Lab
nav_order: 14
parent: DS Labs
layout: page

---
# QuickSort Lab
{: .no_toc}

# üïµÔ∏è Challenge: The AI Code Audit
Subject: Sorting Algorithms & Data Structures

Task: Identify, Debug, and Optimize the "QuickSort" Algorithm


## Task Summary
{: .no_toc .text-delta }
1. TOC
{:toc}




# üö© Part 1: The Investigation
The code below was generated by an AI. It compiles and runs for some inputs, but it is fundamentally broken. It contains 3 logical errors that lead to infinite loops, crashes, or incorrect sorting.

Your Goal: Trace the code on paper with the array [5, 2, 8]. Can you find the 3 bugs?

```java
public static void quickSort(int[] arr, int low, int high) {
    if (low == high) return; // Bug #1?

    int pivotIndex = partition(arr, low, high);

    quickSort(arr, low, pivotIndex); // Bug #2?
    quickSort(arr, pivotIndex, high);
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    return i + 1; // Bug #3?
}
```

# üß™ Part 2: The Stress Test
Once you think you have "fixed" the code, run it against the Stress Test Script. Your code must pass all four levels:

Level 1: Small Random Array (Basic logic)

Level 2: Already Sorted Array (Recursion limits)

Level 3: All Duplicates [5, 5, 5, 5] (Partitioning efficiency)

Level 4: 1,000+ Random Elements (Time complexity)

```java
import java.util.Arrays;
import java.util.Random;

public class QuickSortStressTest {
    public static void main(String[] args) {
        testSmallArray();
        testAlreadySorted();
        testDuplicates();
        testLargeRandomArray();
    }

    public static void testSmallArray() {
        int[] data = {3, 1, 2};
        runTest("Small Array", data);
    }

    public static void testAlreadySorted() {
        int[] data = {1, 2, 3, 4, 5};
        runTest("Already Sorted", data);
    }

    public static void testDuplicates() {
        // Many students' QuickSort logic fails or hangs on identical values
        int[] data = {5, 5, 5, 5, 5};
        runTest("All Duplicates", data);
    }

    public static void testLargeRandomArray() {
        Random rand = new Random();
        int[] data = new int[1000];
        for (int i = 0; i < 1000; i++) data[i] = rand.nextInt(10000);
        runTest("1,000 Random Elements", data);
    }

    private static void runTest(String name, int[] data) {
        int[] expected = data.clone();
        Arrays.sort(expected);
        
        try {
            // This calls the students' class
            BuggyQuickSort.quickSort(data, 0, data.length - 1);
            
            if (Arrays.equals(data, expected)) {
                System.out.println("‚úÖ PASS: " + name);
            } else {
                System.out.println("‚ùå FAIL: " + name + " (Wrong Order)");
                System.out.println("Expected: " + Arrays.toString(expected));
                System.out.println("Actual:   " + Arrays.toString(data));
            }
        } catch (StackOverflowError e) {
            System.out.println("‚ùå FAIL: " + name + " (Stack Overflow - Check your recursion/base case!)");
        } catch (Exception e) {
            System.out.println("‚ùå FAIL: " + name + " (Exception: " + e.getMessage() + ")");
        }
    }
}
```

# üöÄ Part 3: The "Level Up" (AI Integration)

Standard QuickSort often struggles with Level 3 (Duplicates). 
If your code fails Level 3 or runs extremely slowly, use an AI tool as a "Research Consultant" with the following prompts:
- "Why does standard QuickSort have $$O(n^{2})$$ complexity when the array has many duplicate values?"
- "Explain the 'Dutch National Flag' algorithm and how it can be used to optimize QuickSort partitioning."

Task: Implement a 3-Way Partitioning version of QuickSort.

